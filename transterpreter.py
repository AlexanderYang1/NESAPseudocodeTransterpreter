#!/usr/bin/env python3
"""NESA pseudocode transterpreter: pseudocode -> Python (a.py) -> execute."""

from __future__ import annotations

import argparse
import re
import subprocess
import sys
from pathlib import Path


class ParseError(Exception):
    pass


KEYWORD_RE = re.compile(r"^[A-Z][A-Z0-9_ ]*")


def normalise_condition(expr: str) -> str:
    expr = expr.strip()
    expr = re.sub(r"\bAND\b", "and", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bOR\b", "or", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bNOT\b", "not", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bTRUE\b", "True", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bFALSE\b", "False", expr, flags=re.IGNORECASE)
    expr = expr.replace("<>", "!=")

    # Replace equality operator only where it's likely a comparison.
    # Do this after <> replacement so we don't touch !=.
    expr = re.sub(r"(?<![<>=!])=(?!=)", "==", expr)
    return expr


def normalise_expression(expr: str) -> str:
    expr = expr.strip()
    expr = re.sub(r"\bAND\b", "and", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bOR\b", "or", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bNOT\b", "not", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bTRUE\b", "True", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bFALSE\b", "False", expr, flags=re.IGNORECASE)
    expr = expr.replace("<>", "!=")
    return expr


def get_conversion_helper() -> list[str]:
    return [
        "def _try_convert(val):",
        "    try:",
        "        return int(val)",
        "    except ValueError:",
        "        try:",
        "            return float(val)",
        "        except ValueError:",
        "            return val",
        ""
    ]


def split_statements(line: str) -> list[str]:
    return [part.strip() for part in line.split(";") if part.strip()]

def split_plus_top_level(expr: str) -> list[str]:
    parts: list[str] = []
    buf: list[str] = []
    depth = 0
    in_quote = False
    quote_char = ''

    for ch in expr:
        if in_quote:
            buf.append(ch)
            if ch == quote_char:
                in_quote = False
            continue

        if ch in {'"', "'"}:
            in_quote = True
            quote_char = ch
            buf.append(ch)
            continue

        if ch == '(':
            depth += 1
            buf.append(ch)
            continue
        if ch == ')':
            depth = max(0, depth - 1)
            buf.append(ch)
            continue

        if ch == '+' and depth == 0:
            parts.append(''.join(buf).strip())
            buf = []
            continue

        buf.append(ch)

    if buf:
        parts.append(''.join(buf).strip())

    return [p for p in parts if p]


def to_display_python(expr: str) -> str:
    expr = normalise_expression(expr)
    parts = split_plus_top_level(expr)
    if len(parts) <= 1:
        return f"print({expr})"
    joined = ' + '.join([f"str({p})" for p in parts])
    return f"print({joined})"


def translate(lines: list[str]) -> list[str]:
    output: list[str] = [
        "# Auto-generated by transterpreter.py",
        "",
    ]
    output.extend(get_conversion_helper())

    indent = 0
    block_stack: list[tuple[str, int]] = []  # (block_type, source_line)
    seen_top_begin = False

    def emit(code: str) -> None:
        output.append("    " * indent + code)

    for idx, raw in enumerate(lines, start=1):
        line = raw.strip()
        if not line:
            continue

        for stmt in split_statements(line):
            up = stmt.upper()

            if up.startswith("BEGIN "):
                rest = stmt[6:].strip()
                match = re.match(r"([A-Za-z_][A-Za-z0-9_]*)\s*(\((.*)\))?$", rest)
                if not match:
                    raise ParseError(f"Line {idx}: invalid BEGIN syntax: {stmt}")
                name = match.group(1)
                args = (match.group(3) or "").strip()

                if not seen_top_begin:
                    seen_top_begin = True
                    emit(f"def {name}({args}):")
                    indent += 1
                    block_stack.append(("BEGIN_MAIN", idx))
                else:
                    emit(f"def {name}({args}):")
                    indent += 1
                    block_stack.append(("BEGIN_FUNC", idx))
                continue

            if up.startswith("END "):
                if not block_stack:
                    raise ParseError(f"Line {idx}: END without open block")
                kind, _ = block_stack.pop()
                if kind not in {"BEGIN_MAIN", "BEGIN_FUNC"}:
                    raise ParseError(f"Line {idx}: END used for non-BEGIN block")
                indent -= 1
                continue

            if up.startswith("IF ") and up.endswith(" THEN"):
                cond = stmt[3:-5].strip()
                emit(f"if {normalise_condition(cond)}:")
                indent += 1
                block_stack.append(("IF", idx))
                continue

            if up == "ELSE":
                if not block_stack or block_stack[-1][0] != "IF":
                    raise ParseError(f"Line {idx}: ELSE without matching IF")
                indent -= 1
                emit("else:")
                indent += 1
                continue

            if up == "ENDIF":
                if not block_stack or block_stack[-1][0] != "IF":
                    raise ParseError(f"Line {idx}: ENDIF without matching IF")
                block_stack.pop()
                indent -= 1
                continue

            if up.startswith("FOR "):
                # FOR i = 1 TO 10
                m = re.match(r"FOR\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.+)\s+TO\s+(.+)$", stmt, flags=re.IGNORECASE)
                if not m:
                    raise ParseError(f"Line {idx}: invalid FOR syntax: {stmt}")
                var, start, end = m.group(1), m.group(2), m.group(3)
                emit(f"for {var} in range({normalise_expression(start)}, ({normalise_expression(end)}) + 1):")
                indent += 1
                block_stack.append(("FOR", idx))
                continue

            if up == "NEXT":
                if not block_stack or block_stack[-1][0] != "FOR":
                    raise ParseError(f"Line {idx}: NEXT without matching FOR")
                block_stack.pop()
                indent -= 1
                continue

            if up.startswith("WHILE "):
                cond = stmt[6:].strip()
                emit(f"while {normalise_condition(cond)}:")
                indent += 1
                block_stack.append(("WHILE", idx))
                continue

            if up == "ENDWHILE":
                if not block_stack or block_stack[-1][0] != "WHILE":
                    raise ParseError(f"Line {idx}: ENDWHILE without matching WHILE")
                block_stack.pop()
                indent -= 1
                continue

            if up == "REPEAT":
                emit("while True:")
                indent += 1
                block_stack.append(("REPEAT", idx))
                continue

            if up.startswith("UNTIL "):
                if not block_stack or block_stack[-1][0] != "REPEAT":
                    raise ParseError(f"Line {idx}: UNTIL without matching REPEAT")
                cond = stmt[6:].strip()
                emit(f"if {normalise_condition(cond)}:")
                emit("    break")
                block_stack.pop()
                indent -= 1
                continue

            if up.startswith("GET ") or up.startswith("READ "):
                var = stmt.split(maxsplit=1)[1].strip()
                emit(f"{var} = _try_convert(input())")
                continue

            if up.startswith("DISPLAY ") or up.startswith("OUTPUT "):
                expr = stmt.split(maxsplit=1)[1].strip()
                emit(to_display_python(expr))
                continue

            if up.startswith("RETURN "):
                expr = stmt.split(maxsplit=1)[1].strip()
                emit(f"return {normalise_expression(expr)}")
                continue

            # Assignment fallback (e.g. x = y + 1)
            if "=" in stmt and not any(op in up for op in ("IF ", "FOR ")):
                left, right = stmt.split("=", 1)
                emit(f"{left.strip()} = {normalise_expression(right)}")
                continue

            raise ParseError(f"Line {idx}: unsupported statement: {stmt}")

    if block_stack:
        kind, start_line = block_stack[-1]
        raise ParseError(f"Unclosed block {kind} opened at line {start_line}")

    # Add runner for first BEGIN block if there is one.
    for i, line in enumerate(output):
        if line.startswith("def ") and not line.startswith("def _"):
            fn_name = line[4:line.index("(")]
            output.extend([
                "",
                "if __name__ == '__main__':",
                f"    {fn_name}()",
            ])
            break

    return output


def main() -> int:
    parser = argparse.ArgumentParser(description="Translate NESA pseudocode to Python and run it")
    parser.add_argument("input", help="Path to pseudocode source file")
    parser.add_argument("--output", default="a.py", help="Output Python file path (default: a.py)")
    parser.add_argument("--no-run", action="store_true", help="Only generate output, do not execute")
    args = parser.parse_args()

    src = Path(args.input)
    if not src.exists():
        print(f"Input file not found: {src}", file=sys.stderr)
        return 2

    lines = src.read_text(encoding="utf-8").splitlines()

    try:
        py_lines = translate(lines)
    except ParseError as exc:
        print(f"Parse error: {exc}", file=sys.stderr)
        return 1

    out = Path(args.output)
    out.write_text("\n".join(py_lines) + "\n", encoding="utf-8")
    print(f"Generated {out}")

    if args.no_run:
        return 0

    result = subprocess.run([sys.executable, str(out)], check=False)
    return result.returncode


if __name__ == "__main__":
    raise SystemExit(main())
