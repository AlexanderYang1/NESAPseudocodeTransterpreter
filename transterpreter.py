#!/usr/bin/env python3
"""NESA pseudocode transterpreter: pseudocode -> Python (a.py) -> execute."""

from __future__ import annotations

import argparse
import re
import subprocess
import sys
from pathlib import Path


class ParseError(Exception):
    pass


def normalise_condition(expr: str) -> str:
    expr = expr.strip()
    expr = re.sub(r"\bAND\b", "and", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bOR\b", "or", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bNOT\b", "not", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bTRUE\b", "True", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bFALSE\b", "False", expr, flags=re.IGNORECASE)
    expr = expr.replace("<>", "!=")
    expr = re.sub(r"(?<![<>=!])=(?!=)", "==", expr)
    return expr


def normalise_expression(expr: str) -> str:
    expr = expr.strip()
    expr = re.sub(r"\bAND\b", "and", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bOR\b", "or", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bNOT\b", "not", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bTRUE\b", "True", expr, flags=re.IGNORECASE)
    expr = re.sub(r"\bFALSE\b", "False", expr, flags=re.IGNORECASE)
    expr = expr.replace("<>", "!=")
    return expr


def split_statements(line: str) -> list[str]:
    return [part.strip() for part in line.split(";") if part.strip()]


def split_plus_top_level(expr: str) -> list[str]:
    parts: list[str] = []
    buf: list[str] = []
    depth = 0
    in_quote = False
    quote_char = ""

    for ch in expr:
        if in_quote:
            buf.append(ch)
            if ch == quote_char:
                in_quote = False
            continue

        if ch in {'"', "'"}:
            in_quote = True
            quote_char = ch
            buf.append(ch)
            continue

        if ch == "(":
            depth += 1
            buf.append(ch)
            continue

        if ch == ")":
            depth = max(0, depth - 1)
            buf.append(ch)
            continue

        if ch == "+" and depth == 0:
            parts.append("".join(buf).strip())
            buf = []
            continue

        buf.append(ch)

    if buf:
        parts.append("".join(buf).strip())

    return [p for p in parts if p]


def to_display_python(expr: str) -> str:
    expr = normalise_expression(expr)
    parts = split_plus_top_level(expr)
    if len(parts) <= 1:
        return f"print({expr})"
    joined = " + ".join([f"str({p})" for p in parts])
    return f"print({joined})"


def translate(lines: list[str]) -> list[str]:
    output: list[str] = ["# Auto-generated by transterpreter.py", ""]
    indent = 0
    block_stack: list[dict[str, object]] = []
    function_order: list[tuple[str, str]] = []  # (name, args)

    def emit(code: str) -> None:
        output.append("    " * indent + code)

    def handle_simple_statement(stmt: str, idx: int) -> bool:
        up = stmt.upper()

        if up.startswith("GET ") or up.startswith("READ "):
            var = stmt.split(maxsplit=1)[1].strip()
            emit(f"{var} = input()")
            return True

        if up.startswith("DISPLAY ") or up.startswith("OUTPUT "):
            expr = stmt.split(maxsplit=1)[1].strip()
            emit(to_display_python(expr))
            return True

        if up.startswith("RETURN "):
            expr = stmt.split(maxsplit=1)[1].strip()
            emit(f"return {normalise_expression(expr)}")
            return True

        if "=" in stmt and not any(op in up for op in ("IF ", "FOR ", "CASEWHERE ")):
            left, right = stmt.split("=", 1)
            emit(f"{left.strip()} = {normalise_expression(right)}")
            return True

        return False

    for idx, raw in enumerate(lines, start=1):
        line = raw.strip()
        if not line:
            continue

        for stmt in split_statements(line):
            up = stmt.upper()

            if up.startswith("BEGIN "):
                rest = stmt[6:].strip()
                match = re.match(r"([A-Za-z_][A-Za-z0-9_]*)\s*(\((.*)\))?$", rest)
                if not match:
                    raise ParseError(f"Line {idx}: invalid BEGIN syntax: {stmt}")
                name = match.group(1)
                args = (match.group(3) or "").strip()
                emit(f"def {name}({args}):")
                function_order.append((name, args))
                indent += 1
                block_stack.append({"kind": "BEGIN", "line": idx, "name": name})
                continue

            if up.startswith("END "):
                if not block_stack:
                    raise ParseError(f"Line {idx}: END without open block")
                top = block_stack.pop()
                if top["kind"] != "BEGIN":
                    raise ParseError(f"Line {idx}: END used for non-BEGIN block")
                indent -= 1
                continue

            if up.startswith("IF ") and up.endswith(" THEN"):
                cond = stmt[3:-5].strip()
                emit(f"if {normalise_condition(cond)}:")
                indent += 1
                block_stack.append({"kind": "IF", "line": idx})
                continue

            if up == "ELSE":
                if not block_stack or block_stack[-1]["kind"] != "IF":
                    raise ParseError(f"Line {idx}: ELSE without matching IF")
                indent -= 1
                emit("else:")
                indent += 1
                continue

            if up == "ENDIF":
                if not block_stack or block_stack[-1]["kind"] != "IF":
                    raise ParseError(f"Line {idx}: ENDIF without matching IF")
                block_stack.pop()
                indent -= 1
                continue

            if up.startswith("FOR "):
                m = re.match(r"FOR\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.+)\s+TO\s+(.+)$", stmt, flags=re.IGNORECASE)
                if not m:
                    raise ParseError(f"Line {idx}: invalid FOR syntax: {stmt}")
                var, start, end = m.group(1), m.group(2), m.group(3)
                emit(f"for {var} in range({normalise_expression(start)}, ({normalise_expression(end)}) + 1):")
                indent += 1
                block_stack.append({"kind": "FOR", "line": idx})
                continue

            if up == "NEXT":
                if not block_stack or block_stack[-1]["kind"] != "FOR":
                    raise ParseError(f"Line {idx}: NEXT without matching FOR")
                block_stack.pop()
                indent -= 1
                continue

            if up.startswith("WHILE "):
                cond = stmt[6:].strip()
                if cond.upper().endswith(" DO"):
                    cond = cond[:-3].strip()
                emit(f"while {normalise_condition(cond)}:")
                indent += 1
                block_stack.append({"kind": "WHILE", "line": idx})
                continue

            if up == "ENDWHILE":
                if not block_stack or block_stack[-1]["kind"] != "WHILE":
                    raise ParseError(f"Line {idx}: ENDWHILE without matching WHILE")
                block_stack.pop()
                indent -= 1
                continue

            if up == "REPEAT":
                emit("while True:")
                indent += 1
                block_stack.append({"kind": "REPEAT", "line": idx})
                continue

            if up.startswith("UNTIL "):
                if not block_stack or block_stack[-1]["kind"] != "REPEAT":
                    raise ParseError(f"Line {idx}: UNTIL without matching REPEAT")
                cond = stmt[6:].strip()
                emit(f"if {normalise_condition(cond)}:")
                emit("    break")
                block_stack.pop()
                indent -= 1
                continue

            if up.startswith("CASEWHERE ") and up.endswith(" IS"):
                expr = stmt[10:-3].strip()
                block_stack.append(
                    {
                        "kind": "CASE",
                        "line": idx,
                        "expr": normalise_expression(expr),
                        "branch_open": False,
                        "has_case": False,
                    }
                )
                continue

            if up == "ENDCASE":
                if not block_stack or block_stack[-1]["kind"] != "CASE":
                    raise ParseError(f"Line {idx}: ENDCASE without matching CASEWHERE")
                case = block_stack.pop()
                if bool(case["branch_open"]):
                    indent -= 1
                continue

            if block_stack and block_stack[-1]["kind"] == "CASE":
                m_case = re.match(r"(.+?)\s*:\s*(.+)$", stmt)
                if not m_case:
                    raise ParseError(f"Line {idx}: invalid CASE clause: {stmt}")

                label = m_case.group(1).strip()
                rhs = m_case.group(2).strip()
                case = block_stack[-1]

                if bool(case["branch_open"]):
                    indent -= 1

                if label.upper() == "OTHERWISE":
                    emit("else:")
                else:
                    expr = str(case["expr"])
                    clause = "if" if not bool(case["has_case"]) else "elif"
                    emit(f"{clause} {expr} == {normalise_expression(label)}:")
                    case["has_case"] = True

                indent += 1
                case["branch_open"] = True

                if not handle_simple_statement(rhs, idx):
                    raise ParseError(f"Line {idx}: unsupported CASE action: {rhs}")
                continue

            if handle_simple_statement(stmt, idx):
                continue

            raise ParseError(f"Line {idx}: unsupported statement: {stmt}")

    if block_stack:
        top = block_stack[-1]
        raise ParseError(f"Unclosed block {top['kind']} opened at line {top['line']}")

    main_name = None
    if function_order:
        for name, args in function_order:
            if name.upper() == "MAIN" and args.strip() == "":
                main_name = name
                break
        if main_name is None:
            # Fallback to first zero-arg function, then first function.
            for name, args in function_order:
                if args.strip() == "":
                    main_name = name
                    break
            if main_name is None:
                main_name = function_order[0][0]

    if main_name is not None:
        output.extend(["", "if __name__ == '__main__':", f"    {main_name}()"])

    return output


def main() -> int:
    parser = argparse.ArgumentParser(description="Translate NESA pseudocode to Python and run it")
    parser.add_argument("input", help="Path to pseudocode source file")
    parser.add_argument("--output", default="a.py", help="Output Python file path (default: a.py)")
    parser.add_argument("--no-run", action="store_true", help="Only generate output, do not execute")
    args = parser.parse_args()

    src = Path(args.input)
    if not src.exists():
        print(f"Input file not found: {src}", file=sys.stderr)
        return 2

    lines = src.read_text(encoding="utf-8").splitlines()

    try:
        py_lines = translate(lines)
    except ParseError as exc:
        print(f"Parse error: {exc}", file=sys.stderr)
        return 1

    out = Path(args.output)
    out.write_text("\n".join(py_lines) + "\n", encoding="utf-8")
    print(f"Generated {out}")

    if args.no_run:
        return 0

    result = subprocess.run([sys.executable, str(out)], check=False)
    return result.returncode


if __name__ == "__main__":
    raise SystemExit(main())
